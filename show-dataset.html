<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Show Dataset · Optic Lobe CNS Edition</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="https://unpkg.com/plume-css@1.0.13/lib/plume-all.css" />
    <link rel="stylesheet" href="styles/main.css" />
    <style>
      :root {
        --viewer-gap: clamp(1.25rem, 2vw, 2.75rem);
      }

      main.viewer-layout {
        width: 100%;
        padding: clamp(1.5rem, 3vw, 3.5rem);
      }

      .viewer-grid {
        display: grid;
        gap: var(--viewer-gap);
      }

      @media (min-width: 960px) {
        .viewer-grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      .dataset-panel {
        border: 1px solid var(--optic-border);
        border-radius: var(--optic-radius-lg);
        background: rgba(255, 255, 255, 0.02);
        padding: clamp(1.5rem, 2.5vw, 3rem);
        display: flex;
        flex-direction: column;
        gap: 1.25rem;
      }

      .field-grid {
        display: grid;
        gap: 1rem;
      }

      @media (min-width: 640px) {
        .field-grid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }

      label > select {
        margin-top: 0.35rem;
      }

      .status-line {
        min-height: 1.5rem;
        font-size: 0.95rem;
        color: var(--pm-app-font-color);
      }

      .dataset-preview {
        margin-top: 0.5rem;
      }

      .dataset-preview iframe {
        width: 100%;
        min-height: clamp(22rem, 52vh, 42rem);
        border: 1px solid var(--optic-border);
        border-radius: var(--optic-radius-md);
        background: rgba(0, 0, 0, 0.35);
      }

      .dataset-preview.is-hidden {
        display: none;
      }

      .dataset-preview a[aria-disabled="true"] {
        pointer-events: none;
        opacity: 0.55;
      }

      .panel-footer-note {
        font-size: 0.85rem;
        color: var(--pm-app-muted-color, rgba(255, 255, 255, 0.65));
      }
    </style>
  </head>
  <body class="plume pm-surface pm-font-primary">
    <header class="site-header pm-ground pm-padded pm-stacked">
      <div class="pm-container">
        <div class="pm-hgroup">
          <h1>Show Dataset</h1>
          <p class="tagline pm-text-light">Compare neuron metadata side-by-side across datasets.</p>
        </div>
        <nav aria-label="Primary navigation">
          <ul class="nav-list pm-no-margin">
            <li><a class="pm-link" href="index.html">Home</a></li>
            <li><a class="pm-link" href="#datasets">Datasets</a></li>
          </ul>
        </nav>
      </div>
    </header>

    <main id="datasets" class="viewer-layout">
      <div class="viewer-grid">
        <article class="dataset-panel" aria-labelledby="viewerA-title">
          <div class="pm-hgroup">
            <h2 id="viewerA-title" class="pm-h3">Viewer A</h2>
            <p class="pm-text-dimmed pm-small">Pick any dataset + neuron to load an inline preview.</p>
          </div>

          <div class="field-grid">
            <label for="viewerA-dataset-select" class="pm-label">
              Dataset
              <select id="viewerA-dataset-select" class="pm-input" disabled>
                <option value="">Loading datasets…</option>
              </select>
            </label>

            <label for="viewerA-neuron-select" class="pm-label">
              Neuron type
              <select id="viewerA-neuron-select" class="pm-input" disabled>
                <option value="">Select a dataset first</option>
              </select>
            </label>
          </div>

          <p id="viewerA-status" class="status-line">Preparing dataset list…</p>
          <p class="panel-footer-note">
            This viewer fetches the dataset’s <code>static/js/neuron-search.js</code>, parses
            <code>NEURON_TYPES_DATA</code> and <code>NEURON_DATA</code>, and never executes remote scripts.
          </p>

          <div id="viewerA-preview" class="dataset-preview is-hidden">
            <div class="pm-hgroup">
              <h3 class="pm-h4">Neuron page preview</h3>
              <p id="viewerA-preview-message" class="pm-text-dimmed pm-small">Select a neuron to load its page.</p>
            </div>
            <iframe id="viewerA-preview-frame" title="Viewer A neuron detail preview" loading="lazy"></iframe>
            <p class="pm-small pm-space-top">
              <a
                id="viewerA-preview-link"
                class="pm-link"
                href="#"
                target="_blank"
                rel="noopener noreferrer"
                aria-disabled="true"
              >Open this page in a new tab</a>
            </p>
          </div>
        </article>

        <article class="dataset-panel" aria-labelledby="viewerB-title">
          <div class="pm-hgroup">
            <h2 id="viewerB-title" class="pm-h3">Viewer B</h2>
            <p class="pm-text-dimmed pm-small">Use independently to compare another neuron or dataset.</p>
          </div>

          <div class="field-grid">
            <label for="viewerB-dataset-select" class="pm-label">
              Dataset
              <select id="viewerB-dataset-select" class="pm-input" disabled>
                <option value="">Loading datasets…</option>
              </select>
            </label>

            <label for="viewerB-neuron-select" class="pm-label">
              Neuron type
              <select id="viewerB-neuron-select" class="pm-input" disabled>
                <option value="">Select a dataset first</option>
              </select>
            </label>
          </div>

          <p id="viewerB-status" class="status-line">Preparing dataset list…</p>
          <p class="panel-footer-note">
            Each column maintains its own dataset cache, status, and iframe preview for side-by-side analysis.
          </p>

          <div id="viewerB-preview" class="dataset-preview is-hidden">
            <div class="pm-hgroup">
              <h3 class="pm-h4">Neuron page preview</h3>
              <p id="viewerB-preview-message" class="pm-text-dimmed pm-small">Select a neuron to load its page.</p>
            </div>
            <iframe id="viewerB-preview-frame" title="Viewer B neuron detail preview" loading="lazy"></iframe>
            <p class="pm-small pm-space-top">
              <a
                id="viewerB-preview-link"
                class="pm-link"
                href="#"
                target="_blank"
                rel="noopener noreferrer"
                aria-disabled="true"
              >Open this page in a new tab</a>
            </p>
          </div>
        </article>
      </div>
    </main>

    <footer class="site-footer pm-ground pm-padded pm-text-center">
      <div class="pm-container">
        <p>© <span id="year"></span> Optic Lobe CNS Edition · All rights reserved.</p>
      </div>
    </footer>

    <script src="scripts/main.js"></script>
    <script>
      (() => {
        const viewerConfigs = [
          { prefix: 'viewerA' },
          { prefix: 'viewerB' },
        ];

        const palette = {
          info: 'var(--pm-app-font-color)',
          success: '#8ef5c4',
          error: '#ff8f8f',
        };

        const datasetCache = new Map();
        const ABSOLUTE_URL_PATTERN = /^https?:\/\//i;

        const skipWhitespaceAndComments = (text, start = 0) => {
          let index = start;
          while (index < text.length) {
            const char = text[index];
            const next = text[index + 1];
            if (/\s/.test(char)) {
              index += 1;
              continue;
            }
            if (char === '/' && next === '/') {
              index += 2;
              while (index < text.length && text[index] !== '\n') index += 1;
              continue;
            }
            if (char === '/' && next === '*') {
              index += 2;
              while (index < text.length - 1 && !(text[index] === '*' && text[index + 1] === '/')) {
                index += 1;
              }
              index += 2;
              continue;
            }
            break;
          }
          return index;
        };

        const captureBalancedLiteral = (source, startIndex) => {
          const opening = source[startIndex];
          const closing = opening === '[' ? ']' : opening === '{' ? '}' : null;
          if (!closing) return null;

          let depth = 0;
          let inString = false;
          let stringChar = '';
          let escapeNext = false;

          for (let i = startIndex; i < source.length; i += 1) {
            const char = source[i];

            if (inString) {
              if (escapeNext) {
                escapeNext = false;
                continue;
              }
              if (char === '\\') {
                escapeNext = true;
                continue;
              }
              if (char === stringChar) {
                inString = false;
                stringChar = '';
              }
              continue;
            }

            if (char === '"' || char === "'" || char === '`') {
              inString = true;
              stringChar = char;
              continue;
            }

            if (char === opening) {
              depth += 1;
            } else if (char === closing) {
              depth -= 1;
              if (depth === 0) {
                return source.slice(startIndex, i + 1);
              }
            }
          }

          return null;
        };

        const extractConstLiteral = (source, constName) => {
          const pattern = new RegExp(`const\\s+${constName}\\s*=`);
          const match = pattern.exec(source);
          if (!match) return null;
          const literalStart = skipWhitespaceAndComments(source, match.index + match[0].length);
          return captureBalancedLiteral(source, literalStart);
        };

        const parseConstValue = (source, constName) => {
          const literal = extractConstLiteral(source, constName);
          if (!literal) return null;
          try {
            // eslint-disable-next-line no-new-func
            return new Function(`return (${literal});`)();
          } catch (error) {
            console.error(`Failed to parse ${constName}`, error);
            return null;
          }
        };

        const fetchDatasetData = (rawBaseUrl) => {
          const normalizedBase = (rawBaseUrl || '').replace(/\/+$/, '');
          if (!normalizedBase) {
            return Promise.reject(new Error('Dataset is missing a valid base_url.'));
          }

          if (datasetCache.has(normalizedBase)) {
            return datasetCache.get(normalizedBase);
          }

          const loadPromise = (async () => {
            const resourceUrl = `${normalizedBase}/static/js/neuron-search.js`;
            const response = await fetch(resourceUrl, { cache: 'no-store' });
            if (!response.ok) {
              throw new Error(`Failed to fetch neuron-search.js (HTTP ${response.status}).`);
            }

            const scriptText = await response.text();
            const neuronTypes = parseConstValue(scriptText, 'NEURON_TYPES_DATA');
            const neuronData = parseConstValue(scriptText, 'NEURON_DATA');

            if (!Array.isArray(neuronTypes)) {
              throw new Error('neuron-search.js did not expose a parseable NEURON_TYPES_DATA array.');
            }

            return {
              baseUrl: normalizedBase,
              neuronTypes,
              neuronData: Array.isArray(neuronData) ? neuronData : [],
            };
          })().catch((error) => {
            datasetCache.delete(normalizedBase);
            throw error;
          });

          datasetCache.set(normalizedBase, loadPromise);
          return loadPromise;
        };

        const getEntryLabel = (entry) =>
          typeof entry === 'string'
            ? entry
            : entry?.label || entry?.name || entry?.id || entry?.slug || 'Unnamed neuron';

        const normalizeKey = (value) =>
          typeof value === 'string' || typeof value === 'number'
            ? value.toString().trim().toLowerCase()
            : '';

        const buildKeySet = (item) => {
          const keys = new Set();
          const addKey = (candidate) => {
            const normalized = normalizeKey(candidate);
            if (normalized) keys.add(normalized);
          };

          if (typeof item === 'string' || typeof item === 'number') {
            addKey(item);
            return keys;
          }

          if (item && typeof item === 'object') {
            ['name', 'label', 'id', 'slug', 'type'].forEach((field) => addKey(item[field]));
            if (Array.isArray(item.aliases)) {
              item.aliases.forEach(addKey);
            }
          }

          return keys;
        };

        const buildNeuronIndex = (records) => {
          const index = new Map();
          if (!Array.isArray(records)) return index;
          records.forEach((record) => {
            buildKeySet(record).forEach((key) => {
              if (!index.has(key)) {
                index.set(key, record);
              }
            });
          });
          return index;
        };

        const getPrimaryKey = (entry) => {
          const keys = buildKeySet(entry);
          return keys.size ? keys.values().next().value : '';
        };

        const getPrimaryPath = (entry) => {
          if (!entry || typeof entry !== 'object') return '';
          const candidates = ['primary_url', 'primaryUrl', 'primaryURL', 'url', 'href'];
          for (const key of candidates) {
            const value = entry[key];
            if (typeof value === 'string' && value.trim()) {
              return value.trim();
            }
          }
          return '';
        };

        const buildPreviewUrl = (baseUrl, primaryPath) => {
          const cleanedPath = (primaryPath || '').trim();
          if (ABSOLUTE_URL_PATTERN.test(cleanedPath)) {
            return cleanedPath;
          }
          const normalizedBase = (baseUrl || '').replace(/\/+$/, '');
          const sanitizedPath = cleanedPath.replace(/^\/+/, '');
          if (!sanitizedPath) {
            return normalizedBase || 'about:blank';
          }
          return `${normalizedBase}/${sanitizedPath}`;
        };

        const initViewer = (config, datasets) => {
          const datasetSelect = document.getElementById(`${config.prefix}-dataset-select`);
          const neuronSelect = document.getElementById(`${config.prefix}-neuron-select`);
          const statusLine = document.getElementById(`${config.prefix}-status`);
          const previewContainer = document.getElementById(`${config.prefix}-preview`);
          const previewFrame = document.getElementById(`${config.prefix}-preview-frame`);
          const previewMessage = document.getElementById(`${config.prefix}-preview-message`);
          const previewLink = document.getElementById(`${config.prefix}-preview-link`);

          if (
            !datasetSelect ||
            !neuronSelect ||
            !statusLine ||
            !previewContainer ||
            !previewFrame ||
            !previewMessage ||
            !previewLink
          ) {
            return;
          }

          const datasetLookup = new Map();
          datasets.forEach((dataset) => {
            if (!dataset || typeof dataset.base_url !== 'string') return;
            const normalizedBase = dataset.base_url.replace(/\/+$/, '');
            datasetLookup.set(normalizedBase, dataset);
          });

          const state = {
            baseUrl: '',
            neuronEntries: [],
            neuronData: [],
            neuronIndex: new Map(),
          };

          let currentLoadToken = 0;

          const setStatus = (message, tone = 'info') => {
            statusLine.textContent = message;
            statusLine.style.color = palette[tone] || palette.info;
          };

          const resetPreview = (message = 'Select a neuron to load its page.') => {
            previewFrame.src = 'about:blank';
            previewLink.href = '#';
            previewLink.setAttribute('aria-disabled', 'true');
            previewMessage.textContent = message;
            previewContainer.classList.add('is-hidden');
          };

          const showPreview = (url, label) => {
            previewFrame.src = url;
            previewLink.href = url;
            previewLink.removeAttribute('aria-disabled');
            previewMessage.textContent = `Showing page for “${label}”.`;
            previewContainer.classList.remove('is-hidden');
          };

          const resetNeuronSelect = (placeholder = 'Select a dataset first', previewMsg) => {
            neuronSelect.innerHTML = '';
            const option = document.createElement('option');
            option.value = '';
            option.textContent = placeholder;
            neuronSelect.appendChild(option);
            neuronSelect.disabled = true;
            state.neuronEntries = [];
            state.neuronData = [];
            state.neuronIndex = new Map();
            resetPreview(previewMsg || 'Select a neuron to load its page.');
          };

          const populateNeuronOptions = () => {
            neuronSelect.innerHTML = '';
            const defaultOption = document.createElement('option');
            defaultOption.value = '';
            defaultOption.textContent = 'Select a neuron type…';
            neuronSelect.appendChild(defaultOption);

            state.neuronEntries.forEach((entry, index) => {
              const option = document.createElement('option');
              const label = getEntryLabel(entry);
              option.textContent = label;
              const bestKey = getPrimaryKey(entry) || normalizeKey(label) || `__entry_${index}`;
              option.value = bestKey;
              option.dataset.entryIndex = String(index);
              neuronSelect.appendChild(option);
            });

            neuronSelect.disabled = !state.neuronEntries.length;
            if (!state.neuronEntries.length) {
              resetPreview('Neuron data unavailable for this dataset.');
            }
          };

          const findNeuronRecord = (selection, typeEntry) => {
            const selectionKey = normalizeKey(selection);
            if (selectionKey && state.neuronIndex.has(selectionKey)) {
              return state.neuronIndex.get(selectionKey);
            }

            const typeKeys = buildKeySet(typeEntry);
            for (const key of typeKeys) {
              if (state.neuronIndex.has(key)) {
                return state.neuronIndex.get(key);
              }
            }

            return null;
          };

          const populateDatasetOptions = () => {
            datasetSelect.innerHTML = '';
            if (!datasets.length) {
              const option = document.createElement('option');
              option.value = '';
              option.textContent = 'No datasets configured';
              datasetSelect.appendChild(option);
              datasetSelect.disabled = true;
              setStatus('No datasets configured. Update scripts/main.js to add entries.', 'error');
              resetNeuronSelect('Neuron selection disabled', 'Waiting for dataset configuration.');
              return;
            }

            const placeholder = document.createElement('option');
            placeholder.value = '';
            placeholder.textContent = 'Select a dataset…';
            datasetSelect.appendChild(placeholder);

            datasets.forEach((dataset, index) => {
              if (!dataset || typeof dataset.base_url !== 'string') return;
              const option = document.createElement('option');
              option.value = dataset.base_url.replace(/\/+$/, '');
              option.textContent = dataset.name || `Dataset ${index + 1}`;
              datasetSelect.appendChild(option);
            });

            datasetSelect.disabled = false;
            setStatus('Select a dataset to begin.');
          };

          datasetSelect.addEventListener('change', (event) => {
            const selectedBase = (event.target.value || '').trim();
            currentLoadToken += 1;

            if (!selectedBase) {
              resetNeuronSelect('Select a dataset first');
              setStatus('Choose a dataset to load neuron metadata.');
              return;
            }

            const datasetMeta = datasetLookup.get(selectedBase);
            const datasetLabel = datasetMeta?.name || 'dataset';

            resetNeuronSelect('Loading neuron types…', 'Loading neuron data…');
            setStatus(`Fetching neuron list from ${datasetLabel}…`);

            const loadToken = currentLoadToken;

            fetchDatasetData(selectedBase)
              .then((data) => {
                if (loadToken !== currentLoadToken) return;
                state.baseUrl = data.baseUrl;
                state.neuronEntries = Array.isArray(data.neuronTypes) ? data.neuronTypes : [];
                state.neuronData = Array.isArray(data.neuronData) ? data.neuronData : [];
                state.neuronIndex = buildNeuronIndex(state.neuronData);
                populateNeuronOptions();
                if (!state.neuronEntries.length) {
                  setStatus(`No neuron types were parsed for ${datasetLabel}.`, 'error');
                  resetPreview('No neuron data available for this dataset.');
                  return;
                }
                if (!state.neuronIndex.size) {
                  setStatus(`NEURON_DATA entries are missing for ${datasetLabel}.`, 'error');
                  resetPreview('This dataset does not expose NEURON_DATA metadata.');
                  return;
                }
                setStatus(
                  `Loaded ${state.neuronEntries.length} neuron types with ${state.neuronIndex.size} NEURON_DATA records from ${datasetLabel}.`,
                  'success',
                );
              })
              .catch((error) => {
                if (loadToken !== currentLoadToken) return;
                console.error(error);
                resetNeuronSelect('Neuron data unavailable', 'Neuron data unavailable for this dataset.');
                setStatus(error.message || 'Failed to load neuron data.', 'error');
              });
          });

          neuronSelect.addEventListener('change', () => {
            const selection = neuronSelect.value;
            if (!selection) {
              resetPreview('Select a neuron to load its page.');
              setStatus('Select a neuron to load its page.');
              return;
            }

            const selectedOption = neuronSelect.selectedOptions[0];
            const entryIndex = selectedOption?.dataset.entryIndex;
            const typeEntry =
              typeof entryIndex !== 'undefined' ? state.neuronEntries[Number(entryIndex)] : null;
            const record = findNeuronRecord(selection, typeEntry);

            if (!state.baseUrl) {
              setStatus('Select a dataset before choosing a neuron.', 'error');
              resetPreview('Select a dataset before choosing a neuron.');
              return;
            }

            if (!record) {
              setStatus('No matching NEURON_DATA entry was found for this neuron.', 'error');
              resetPreview('This neuron is missing NEURON_DATA metadata.');
              return;
            }

            const primaryPath = getPrimaryPath(record);

            if (!primaryPath) {
              setStatus('Selected neuron is missing primary_url metadata in NEURON_DATA.', 'error');
              resetPreview('No primary URL is available for this neuron.');
              return;
            }

            const previewUrl = buildPreviewUrl(state.baseUrl, primaryPath);
            const label = selectedOption?.textContent?.trim() || selection;
            setStatus(`Loading neuron page preview for “${label}”…`);
            showPreview(previewUrl, label);
          });

          setStatus('Preparing dataset list…');
          resetNeuronSelect();
          populateDatasetOptions();
        };

        document.addEventListener('DOMContentLoaded', () => {
          const yearEl = document.getElementById('year');
          if (yearEl) {
            yearEl.textContent = new Date().getFullYear();
          }

          const registry = window.opticDatasetRegistry;
          const datasets = Array.isArray(registry?.all?.()) ? registry.all() : [];

          viewerConfigs.forEach((config) => initViewer(config, datasets));
        });
      })();
    </script>
  </body>
</html>