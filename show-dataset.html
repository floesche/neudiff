<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>neuDiff Viewer</title>
  <link rel="stylesheet" href="https://unpkg.com/plume-css@1.0.13/lib/plume-all.css" />
  <link rel="stylesheet" href="styles/main.css" />
  <style>
    :root {
      --viewer-header-height: clamp(3.25rem, 4vw, 4.25rem);
    }

    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    .viewer-header {
      position: sticky;
      top: 0;
      z-index: 20;
      display: flex;
      align-items: center;
      flex-wrap: nowrap;
      gap: 0.75rem;
      width: 100%;
      padding: 0.75rem clamp(1rem, 3vw, 2rem);
      backdrop-filter: blur(22px);
      background: rgba(4, 7, 15, 0.85);
      border-bottom: 1px solid var(--optic-border, rgba(255, 255, 255, 0.12));
    }

    .primary-link {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      min-height: calc(var(--viewer-header-height) - 0.5rem);
      padding-inline: 1rem;
      flex: 0 1 calc(100% / 12);
      max-width: calc(100% / 12);
      min-width: 4.5rem;
    }

    .primary-link--left {
      justify-content: flex-start;
      text-align: left;
    }

    .primary-link--right {
      justify-content: flex-end;
      text-align: right;
    }

    .viewer-controls {
      flex: 0 1 calc((100% / 12) * 10 - 1.5rem);
      max-width: calc((100% / 12) * 10 - 1.5rem);
      min-width: 0;
      margin-inline: auto;
      display: grid;
      grid-template-columns: repeat(4, minmax(8.25rem, 1fr));
      gap: 0.6rem;
      align-items: center;
    }

    .viewer-controls .selector {
      min-width: 0;
    }

    .selector {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      min-width: 0;
    }

    .selector label {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(247, 251, 255, 0.8);
    }

    .selector select {
      min-height: calc(var(--viewer-header-height) - 0.5rem);
      padding-block: 0.35rem;
    }

    main.viewer-split {
      flex: 1 1 auto;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: clamp(0.75rem, 2vw, 1.5rem);
      padding: clamp(0.75rem, 2vw, 1.5rem);
    }

    .pane {
      border: 1px solid var(--optic-border, rgba(255, 255, 255, 0.12));
      border-radius: var(--optic-radius-lg, 24px);
      overflow: hidden;
      background: linear-gradient(145deg, rgba(4, 7, 15, 0.65), rgba(4, 7, 15, 0.4));
      display: flex;
      box-shadow: 0 12px 35px rgba(0, 0, 0, 0.45);
    }

    .pane.is-hidden {
      display: none;
    }

    .pane iframe {
      border: none;
      width: 100%;
      flex: 1;
      background: transparent;
      min-height: 100000px;
    }

    @media (max-width: 960px) {
      .viewer-header {
        flex-wrap: wrap;
      }

      .primary-link {
        flex: 1 1 100%;
        max-width: none;
      }

      .viewer-controls {
        flex: 1 1 100%;
        max-width: 100%;
        margin-inline: 0;
        grid-template-columns: repeat(2, minmax(8.5rem, 1fr));
      }
    }

    @media (max-width: 720px) {
      .viewer-controls {
        grid-template-columns: repeat(auto-fit, minmax(9rem, 1fr));
      }
    }
  </style>
</head>
<body class="plume pm-surface pm-font-primary">
  <header class="viewer-header">
    <a class="pm-button pm-btn-primary primary-link primary-link--left" href="show-dataset.html" aria-current="page">neuDiff</a>

    <div class="viewer-controls">
      <div class="selector">
        <label for="viewerA-dataset-select">Dataset 1</label>
        <select id="viewerA-dataset-select" class="pm-input" disabled>
          <option value="">Choose dataset</option>
        </select>
      </div>
      <div class="selector">
        <label for="viewerA-neuron-select">Neuron 1</label>
        <select id="viewerA-neuron-select" class="pm-input" disabled>
          <option value="">Choose neuron type</option>
        </select>
      </div>
      <div class="selector">
        <label for="viewerB-dataset-select">Dataset 2</label>
        <select id="viewerB-dataset-select" class="pm-input" disabled>
          <option value="">Choose dataset</option>
        </select>
      </div>
      <div class="selector">
        <label for="viewerB-neuron-select">Neuron 2</label>
        <select id="viewerB-neuron-select" class="pm-input" disabled>
          <option value="">Choose neuron type</option>
        </select>
      </div>
    </div>

    <a class="pm-button pm-btn-primary primary-link primary-link--right" href="help.html">Help</a>
  </header>

  <main class="viewer-split" aria-label="Neuron previews">
    <section id="viewerA-preview" class="pane is-hidden" aria-label="Viewer 1">
      <iframe id="viewerA-frame" title="Viewer 1 neuron preview" src="about:blank" loading="lazy"></iframe>
    </section>
    <section id="viewerB-preview" class="pane is-hidden" aria-label="Viewer 2">
      <iframe id="viewerB-frame" title="Viewer 2 neuron preview" src="about:blank" loading="lazy"></iframe>
    </section>
  </main>

  <script src="scripts/main.js"></script>
  <script>
    (() => {
      const viewerConfigs = [
        { prefix: 'viewerA' },
        { prefix: 'viewerB' },
      ];

      const datasetCache = new Map();
      const ABSOLUTE_URL_PATTERN = /^https?:\/\//i;

      const skipWhitespaceAndComments = (text, start = 0) => {
        let index = start;
        while (index < text.length) {
          const char = text[index];
          const next = text[index + 1];
          if (/\s/.test(char)) {
            index += 1;
            continue;
          }
          if (char === '/' && next === '/') {
            index += 2;
            while (index < text.length && text[index] !== '\n') index += 1;
            continue;
          }
          if (char === '/' && next === '*') {
            index += 2;
            while (index < text.length - 1 && !(text[index] === '*' && text[index + 1] === '/')) {
              index += 1;
            }
            index += 2;
            continue;
          }
          break;
        }
        return index;
      };

      const captureBalancedLiteral = (source, startIndex) => {
        const opening = source[startIndex];
        const closing = opening === '[' ? ']' : opening === '{' ? '}' : null;
        if (!closing) return null;

        let depth = 0;
        let inString = false;
        let stringChar = '';
        let escapeNext = false;

        for (let i = startIndex; i < source.length; i += 1) {
          const char = source[i];

          if (inString) {
            if (escapeNext) {
              escapeNext = false;
              continue;
            }
            if (char === '\\') {
              escapeNext = true;
              continue;
            }
            if (char === stringChar) {
              inString = false;
              stringChar = '';
            }
            continue;
          }

          if (char === '"' || char === "'" || char === '`') {
            inString = true;
            stringChar = char;
            continue;
          }

          if (char === opening) {
            depth += 1;
          } else if (char === closing) {
            depth -= 1;
            if (depth === 0) {
              return source.slice(startIndex, i + 1);
            }
          }
        }

        return null;
      };

      const extractConstLiteral = (source, constName) => {
        const pattern = new RegExp(`const\\s+${constName}\\s*=`);
        const match = pattern.exec(source);
        if (!match) return null;
        const literalStart = skipWhitespaceAndComments(source, match.index + match[0].length);
        return captureBalancedLiteral(source, literalStart);
      };

      const parseConstValue = (source, constName) => {
        const literal = extractConstLiteral(source, constName);
        if (!literal) return null;
        try {
          // eslint-disable-next-line no-new-func
          return new Function(`return (${literal});`)();
        } catch (error) {
          console.error(`Failed to parse ${constName}`, error);
          return null;
        }
      };

      const fetchDatasetData = (rawBaseUrl) => {
        const normalizedBase = (rawBaseUrl || '').replace(/\/+$/, '');
        if (!normalizedBase) {
          return Promise.reject(new Error('Dataset is missing a valid base_url.'));
        }

        if (datasetCache.has(normalizedBase)) {
          return datasetCache.get(normalizedBase);
        }

        const loadPromise = (async () => {
          const resourceUrl = `${normalizedBase}/static/js/neuron-search.js`;
          const response = await fetch(resourceUrl, { cache: 'no-store' });
          if (!response.ok) {
            throw new Error(`Failed to fetch neuron-search.js (HTTP ${response.status}).`);
          }

          const scriptText = await response.text();
          const neuronTypes = parseConstValue(scriptText, 'NEURON_TYPES_DATA');
          const neuronData = parseConstValue(scriptText, 'NEURON_DATA');

          if (!Array.isArray(neuronTypes)) {
            throw new Error('neuron-search.js did not expose a parseable NEURON_TYPES_DATA array.');
          }

          return {
            baseUrl: normalizedBase,
            neuronTypes,
            neuronData: Array.isArray(neuronData) ? neuronData : [],
          };
        })().catch((error) => {
          datasetCache.delete(normalizedBase);
          throw error;
        });

        datasetCache.set(normalizedBase, loadPromise);
        return loadPromise;
      };

      const getEntryLabel = (entry) =>
        typeof entry === 'string'
          ? entry
          : entry?.label || entry?.name || entry?.id || entry?.slug || 'Neuron';

      const normalizeKey = (value) =>
        typeof value === 'string' || typeof value === 'number'
          ? value.toString().trim().toLowerCase()
          : '';

      const buildKeySet = (item) => {
        const keys = new Set();
        const addKey = (candidate) => {
          const normalized = normalizeKey(candidate);
          if (normalized) keys.add(normalized);
        };

        if (typeof item === 'string' || typeof item === 'number') {
          addKey(item);
          return keys;
        }

        if (item && typeof item === 'object') {
          ['name', 'label', 'id', 'slug', 'type'].forEach((field) => addKey(item[field]));
          if (Array.isArray(item.aliases)) {
            item.aliases.forEach(addKey);
          }
        }

        return keys;
      };

      const buildNeuronIndex = (records) => {
        const index = new Map();
        if (!Array.isArray(records)) return index;
        records.forEach((record) => {
          buildKeySet(record).forEach((key) => {
            if (!index.has(key)) {
              index.set(key, record);
            }
          });
        });
        return index;
      };

      const getPrimaryKey = (entry) => {
        const keys = buildKeySet(entry);
        return keys.size ? keys.values().next().value : '';
      };

      const getPrimaryPath = (entry) => {
        if (!entry || typeof entry !== 'object') return '';
        const candidates = ['primary_url', 'primaryUrl', 'primaryURL', 'url', 'href'];
        for (const key of candidates) {
          const value = entry[key];
          if (typeof value === 'string' && value.trim()) {
            return value.trim();
          }
        }
        return '';
      };

      const buildPreviewUrl = (baseUrl, primaryPath) => {
        const cleanedPath = (primaryPath || '').trim();
        if (ABSOLUTE_URL_PATTERN.test(cleanedPath)) {
          return cleanedPath;
        }
        const normalizedBase = (baseUrl || '').replace(/\/+$/, '');
        const sanitizedPath = cleanedPath.replace(/^\//, '');
        if (!sanitizedPath) {
          return normalizedBase || 'about:blank';
        }
        return `${normalizedBase}/${sanitizedPath}`;
      };

      const initViewer = (config, datasets) => {
        const datasetSelect = document.getElementById(`${config.prefix}-dataset-select`);
        const neuronSelect = document.getElementById(`${config.prefix}-neuron-select`);
        const frame = document.getElementById(`${config.prefix}-frame`);
        const previewPane = document.getElementById(`${config.prefix}-preview`);

        if (!datasetSelect || !neuronSelect || !frame || !previewPane) {
          return;
        }

        const state = {
          baseUrl: '',
          neuronEntries: [],
          neuronData: [],
          neuronIndex: new Map(),
        };

        let currentLoadToken = 0;

        const hidePreviewPane = () => {
          frame.src = 'about:blank';
          previewPane.classList.add('is-hidden');
        };

        const showPreviewPane = () => {
          previewPane.classList.remove('is-hidden');
        };

        const resetNeuronSelect = () => {
          neuronSelect.innerHTML = '';
          const option = document.createElement('option');
          option.value = '';
          option.textContent = 'Choose neuron type';
          option.disabled = true;
          option.selected = true;
          neuronSelect.appendChild(option);
          neuronSelect.disabled = true;
          state.neuronEntries = [];
          state.neuronData = [];
          state.neuronIndex = new Map();
          hidePreviewPane();
        };

        const populateNeuronOptions = () => {
          neuronSelect.innerHTML = '';
          const defaultOption = document.createElement('option');
          defaultOption.value = '';
          defaultOption.textContent = 'Choose neuron type';
          defaultOption.disabled = true;
          defaultOption.selected = true;
          neuronSelect.appendChild(defaultOption);

          state.neuronEntries.forEach((entry, index) => {
            const option = document.createElement('option');
            const label = getEntryLabel(entry);
            option.textContent = label;
            const bestKey = getPrimaryKey(entry) || normalizeKey(label) || `__entry_${index}`;
            option.value = bestKey;
            option.dataset.entryIndex = String(index);
            neuronSelect.appendChild(option);
          });

          neuronSelect.disabled = !state.neuronEntries.length;
        };

        const populateDatasetOptions = () => {
          datasetSelect.innerHTML = '';
          if (!datasets.length) {
            const emptyOption = document.createElement('option');
            emptyOption.value = '';
            emptyOption.textContent = 'No datasets configured';
            emptyOption.disabled = true;
            emptyOption.selected = true;
            datasetSelect.appendChild(emptyOption);
            datasetSelect.disabled = true;
            resetNeuronSelect();
            hidePreviewPane();
            return;
          }

          const placeholder = document.createElement('option');
          placeholder.value = '';
          placeholder.textContent = 'Choose dataset';
          placeholder.disabled = true;
          placeholder.selected = true;
          datasetSelect.appendChild(placeholder);

          datasets.forEach((dataset, index) => {
            if (!dataset || typeof dataset.base_url !== 'string') return;
            const option = document.createElement('option');
            option.value = dataset.base_url.replace(/\/+$/, '');
            option.textContent = dataset.name || `Dataset ${index + 1}`;
            datasetSelect.appendChild(option);
          });

          datasetSelect.disabled = false;
        };

        datasetSelect.addEventListener('change', (event) => {
          const selectedBase = (event.target.value || '').trim();
          currentLoadToken += 1;

          hidePreviewPane();

          if (!selectedBase) {
            resetNeuronSelect();
            return;
          }

          resetNeuronSelect();

          const loadToken = currentLoadToken;

          fetchDatasetData(selectedBase)
            .then((data) => {
              if (loadToken !== currentLoadToken) return;
              state.baseUrl = data.baseUrl;
              state.neuronEntries = Array.isArray(data.neuronTypes) ? data.neuronTypes : [];
              state.neuronData = Array.isArray(data.neuronData) ? data.neuronData : [];
              state.neuronIndex = buildNeuronIndex(state.neuronData);
              populateNeuronOptions();
            })
            .catch((error) => {
              console.error(error);
              if (loadToken !== currentLoadToken) return;
              state.baseUrl = '';
              state.neuronEntries = [];
              state.neuronData = [];
              state.neuronIndex = new Map();
              resetNeuronSelect();
              hidePreviewPane();
            });
        });

        neuronSelect.addEventListener('change', () => {
          const selection = neuronSelect.value;
          if (!selection || !state.baseUrl) {
            hidePreviewPane();
            return;
          }

          const selectedOption = neuronSelect.selectedOptions[0];
          const entryIndex = selectedOption?.dataset.entryIndex;
          const typeEntry =
            typeof entryIndex !== 'undefined' ? state.neuronEntries[Number(entryIndex)] : null;

          const selectionKey = normalizeKey(selection);
          let record = null;

          if (selectionKey && state.neuronIndex.has(selectionKey)) {
            record = state.neuronIndex.get(selectionKey);
          } else if (typeEntry) {
            const typeKeys = buildKeySet(typeEntry);
            for (const key of typeKeys) {
              if (state.neuronIndex.has(key)) {
                record = state.neuronIndex.get(key);
                break;
              }
            }
          }

          if (!record) {
            hidePreviewPane();
            return;
          }

          const primaryPath = getPrimaryPath(record);
          if (!primaryPath) {
            hidePreviewPane();
            return;
          }

          showPreviewPane();
          frame.src = buildPreviewUrl(state.baseUrl, primaryPath);
        });

        resetNeuronSelect();
        populateDatasetOptions();
      };

      document.addEventListener('DOMContentLoaded', () => {
        const registry = window.opticDatasetRegistry;
        const datasets = Array.isArray(registry?.all?.()) ? registry.all() : [];

        viewerConfigs.forEach((config) => initViewer(config, datasets));
      });
    })();
  </script>
</body>
</html>